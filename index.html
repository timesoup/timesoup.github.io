<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Swipeable Content App - Shorts UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior-y: contain;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scroll */
            background-color: #000;
        }
        #appContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
            background-color: #000; /* Ensure container background is black for fullscreen */
        }
        .swipe-item {
            width: 100%; 
            height: 100vh; 
            flex-shrink: 0; 
            background-color: #111; 
            overflow: hidden; 
            position: relative; 
            scroll-snap-align: start; /* For smooth scrollTo behavior */
        }
        #swipeContainer::-webkit-scrollbar {
            display: none;
        }
        #swipeContainer {
            width: 100%;
            height: 100%;
            display: flex; 
            flex-direction: column;
            overflow-y: auto; 
            -ms-overflow-style: none;
            scrollbar-width: none;
            scroll-snap-type: y mandatory; 
        }
        .loader {
            border: 6px solid #444;
            border-top: 6px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        .iframe-content {
            width: 100%;
            height: 100%;
            border: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; 
        }

        #swipeCaptureLayer { /* This layer is passive for touches, allowing events to pass through */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10; 
            pointer-events: none; /* Allows all touches to pass through to content below by default */
        }

        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Base overlay doesn't catch events */
            z-index: 20; 
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            color: white;
        }

        /* Specific children of uiOverlay that should receive pointer events */
        #uiOverlay .actions-sidebar { /* This one remains interactive for app swipes and its buttons */
            pointer-events: auto; 
        }
        #uiOverlay .content-info { /* This one becomes passive to events, passing them to game underneath */
            pointer-events: none; 
        }


        .actions-sidebar {
            position: absolute;
            right: 8px;
            bottom: 80px; 
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px; 
        }
        .actions-sidebar .action-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            font-size: 12px;
            padding: 5px; 
        }
        .actions-sidebar .action-button i {
            font-size: 28px; 
            margin-bottom: 4px;
        }
         .actions-sidebar .profile-icon-container {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px; 
            border: 2px solid white;
        }
        .actions-sidebar .profile-icon-container i {
             font-size: 20px;
             color: #fff;
        }
        .content-info { /* Visually present, but events pass through due to pointer-events: none above */
            padding: 12px;
            background: linear-gradient(to top, rgba(0,0,0,0.6), rgba(0,0,0,0));
        }
        .content-info .channel-name {
            font-weight: bold;
            font-size: 16px;
        }
        .content-info .description {
            font-size: 14px;
            margin-top: 4px;
            line-height: 1.3;
        }
    </style>
</head>
<body class="bg-black">

    <div id="appContainer">
        <div id="swipeContainer">
            </div>

        <div id="swipeCaptureLayer"></div> 

        <div id="uiOverlay">
            <div class="actions-sidebar">
                <div id="fullscreenButton" class="action-button"> <i class="fas fa-expand"></i>
                    <span>Full</span>
                </div>
                <div class="action-button">
                    <i class="fas fa-thumbs-up"></i>
                    <span>Like</span>
                </div>
                <div class="action-button">
                    <i class="fas fa-thumbs-down"></i>
                    <span>Dislike</span>
                </div>
                <div class="action-button">
                    <i class="fas fa-comment-dots"></i>
                    <span>123</span>
                </div>
                <div class="action-button">
                    <i class="fas fa-share"></i>
                    <span>Share</span>
                </div>
                <div class="action-button">
                    <i class="fas fa-ellipsis-h"></i>
                </div>
                 <div class="action-button profile-icon-container">
                    <i class="fas fa-user"></i>
                </div>
            </div>

            <div class="content-info"> <div class="channel-name">@ChannelName</div>
                <div class="description">This is a cool video or game description... #hashtag</div>
            </div>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // --- Configuration ---
        const contentItems = [
            { type: 'video', videoId: 'k6XZ-hLbs-c', id: 'video0', title: '@chang0000', description: 'How's it feel when my crush like me back? üò≥ #chang0000 #chany #c4class },
            { type: 'video', videoId: 'T63_uz4-OuY', id: 'video1', title: '@engineerusa44', description: '181/LikeComment Subscribe"#SEO-driven#adamrose #construction #engineering #NYC #NewYorkCity #NYCVlog' },            
            { type: 'game', url: 'https://gamesnacks.com/games/6e0ej8ct9hdj8#sc=1746578696109227372-2828726', id: 'game0', title: 'Puzzle Challenge', description: 'Test your puzzle solving skills. #puzzle #brainteaser' },
            { type: 'video', videoId: 'J2Zqn4dXuno', id: 'video2', title: '@LUCKY MAN 10M', description: 'Moment Before Cooked ‚ò†Ô∏è #trollface #edit #shorts' },
            { type: 'game', url: 'https://gamesnacks.com/games/5pj67mkaqugmo', id: 'game1', title: 'Retro Racer', description: 'Classic racing action. #retro #racing' },
            { type: 'game', url: 'https://gamesnacks.com/games/7u583tvdi3f00', id: 'game2', title: 'Space Adventure', description: 'Explore the galaxy in this epic adventure! #space #scifi' },
            { type: 'game', url: 'https://gamesnacks.com/games/0s1do8fmhrn9g#sc=1746578696103593132-2828726', id: 'game3', title: 'Cool Game 1', description: 'Play this amazing arcade game and beat the high score! #arcade #fun' },
            { type: 'video', videoId: 'VB5EVwbqmeE', id: 'video3', title: 'Funny Moments', description: 'A collection of hilarious clips. #funny #comedy' },

            { type: 'video', videoId: 'jKISt-_GeQk', id: 'video4', title: '@RedFrame2', description: '#Move' },            
            { type: 'video', videoId: 'gWF6RiY251M', id: 'video5', title: '@JasminandJames', description: 'Magic trick REVEALED‚Ä¶ üëÄüò±ü§£ | Jasmin and James #Shorts' },            
            { type: 'video', videoId: 'cn965afzoe8', id: 'video6', title: '@ZachKing', description: 'Who enjoyed seeing the solar eclipse' },            
            { type: 'video', videoId: '9efannizT9E', id: 'video7', title: '@Bachiraa-Editz', description: 'The Best Parkour üóø' }            

        
        ];

        // --- State ---
        let currentItemIndex = 0;
        const youtubePlayers = {};
        const preloadedIframes = {}; 
        const PRELOAD_AHEAD = 1;

        // --- DOM Elements ---
        const appContainer = document.getElementById('appContainer'); // Touch listeners for app navigation are here
        const swipeContainer = document.getElementById('swipeContainer');
        const uiOverlay = document.getElementById('uiOverlay');
        const uiActionsSidebar = uiOverlay.querySelector('.actions-sidebar');
        const uiChannelName = uiOverlay.querySelector('.channel-name');
        const uiDescription = uiOverlay.querySelector('.description');
        const fullscreenButton = document.getElementById('fullscreenButton');


        // --- Swipe Control State ---
        let touchStartY = 0;
        let touchStartScrollTop = 0;
        let isAppNavigating = false; // True if swipe started on UI elements designated for app navigation
        
        const MIN_SWIPE_DISTANCE_FOR_NAVIGATION = 60; // Min dy at touchend to navigate.

        // --- Fullscreen Function ---
        function requestFullScreen() {
            const elem = document.documentElement; // Get the root HTML element
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else if (elem.mozRequestFullScreen) { /* Firefox */
                elem.mozRequestFullScreen().catch(err => {
                    console.warn(`Error attempting to enable full-screen mode (Firefox): ${err.message} (${err.name})`);
                });
            } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT).catch(err => {
                     console.warn(`Error attempting to enable full-screen mode (WebKit): ${err.message} (${err.name})`);
                });
            } else if (elem.msRequestFullscreen) { /* IE/Edge */
                elem.msRequestFullscreen().catch(err => {
                    console.warn(`Error attempting to enable full-screen mode (MS): ${err.message} (${err.name})`);
                });
            }
        }


        // --- YouTube API Functions ---
        window.onYouTubeIframeAPIReady = function() {
            console.log("YouTube IFrame API Ready");
            initializeVisibleContent();
        }

        function createYoutubePlayer(item, itemDiv) {
            const iframeId = `ytplayer-${item.id}`;
            const playerDiv = document.createElement('div');
            playerDiv.id = iframeId;
            playerDiv.className = 'iframe-content';
            itemDiv.appendChild(playerDiv);
            preloadedIframes[contentItems.indexOf(item)] = playerDiv;

            youtubePlayers[item.id] = new YT.Player(iframeId, {
                height: '100%', width: '100%', videoId: item.videoId,
                playerVars: {
                    'playsinline': 1, 'autoplay': 0, 'controls': 0,
                    'origin': window.location.origin, 'enablejsapi': 1,
                    'modestbranding': 1, 'showinfo': 0, 'rel': 0
                },
                events: { 
                    'onReady': (event) => onPlayerReady(event, item), 
                    'onStateChange': onPlayerStateChange 
                }
            });
        }

        function onPlayerReady(event, item) {
            console.log(`Player ready for ${item.id}`);
            const itemIndex = contentItems.findIndex(ci => ci.id === item.id);
            const itemDiv = swipeContainer.querySelector(`.swipe-item[data-index='${itemIndex}']`);
            if (itemDiv) {
                const loader = itemDiv.querySelector('.loader');
                if (loader) loader.remove();
            }
            if (itemIndex === currentItemIndex) {
                setTimeout(() => {
                    if (event.target && typeof event.target.playVideo === 'function') {
                        event.target.playVideo();
                    }
                }, 100);
            }
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                // scrollToItem(currentItemIndex + 1); // Optionally auto-advance
            }
        }

        // --- Content Loading and Management ---
        function createItemElement(itemData, index) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'swipe-item'; // CSS handles sizing and layout
            itemDiv.dataset.index = index;
            itemDiv.dataset.id = itemData.id;
            itemDiv.dataset.type = itemData.type;
            
            const loader = document.createElement('div');
            loader.className = 'loader';
            itemDiv.appendChild(loader);
            
            swipeContainer.appendChild(itemDiv);
            return itemDiv;
        }
        
        function loadItemContent(itemIndex) {
            if (itemIndex < 0 || itemIndex >= contentItems.length) return;
            if (preloadedIframes[itemIndex]) return; // Already loaded

            const itemData = contentItems[itemIndex];
            const itemDiv = swipeContainer.querySelector(`.swipe-item[data-index='${itemIndex}']`);
            if (!itemDiv) {
                console.error("Item div not found for index:", itemIndex);
                return;
            }
            
            if (itemData.type === 'video') {
                if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                    console.warn("YouTube API not ready for video", itemData.id, "- will try when API is ready.");
                } else {
                    createYoutubePlayer(itemData, itemDiv);
                }
            } else if (itemData.type === 'game') {
                const iframe = document.createElement('iframe');
                iframe.className = 'iframe-content';
                iframe.src = itemData.url;
                iframe.setAttribute('frameborder', '0');
                iframe.setAttribute('allow', 'gamepad; autoplay; fullscreen;');
                iframe.setAttribute('allowfullscreen', '');
                iframe.setAttribute('scrolling', 'no');
                itemDiv.appendChild(iframe);
                preloadedIframes[itemIndex] = iframe;
                iframe.onload = () => {
                    console.log(`Game loaded: ${itemData.url}`);
                    const loader = itemDiv.querySelector('.loader');
                    if (loader) loader.remove();
                };
                iframe.onerror = () => {
                    console.error(`Error loading game: ${itemData.url}`);
                    const loader = itemDiv.querySelector('.loader');
                    if (loader) loader.textContent = "Error loading game.";
                };
            }
        }
        
        function updateDisplayedItemInfo(index) {
            if (index >= 0 && index < contentItems.length) {
                const item = contentItems[index];
                uiChannelName.textContent = `@${item.title.replace(/\s+/g, '').substring(0,20) || 'Channel'}`;
                uiDescription.textContent = item.description.substring(0, 100) || 'No description available.';
            }
        }

        function initializeVisibleContent() {
            contentItems.forEach((item, index) => createItemElement(item, index));
            // Set initial scroll position after items are in DOM
            swipeContainer.scrollTop = currentItemIndex * window.innerHeight;
            updatePreloadedContent(currentItemIndex);
            updateDisplayedItemInfo(currentItemIndex);
        }

        function updatePreloadedContent(newIndex) {
            loadItemContent(newIndex); // Load current
            for (let i = 1; i <= PRELOAD_AHEAD; i++) { // Load neighbors
                loadItemContent(newIndex + i);
                loadItemContent(newIndex - i);
            }
        }

        function scrollToItem(index) {
            const newValidIndex = Math.max(0, Math.min(index, contentItems.length - 1));
            const targetScrollTop = newValidIndex * window.innerHeight;
            swipeContainer.scrollTo({
                top: targetScrollTop,
                behavior: 'smooth'
            });
            // scroll event + handleScrollEnd will manage state updates
        }

        // --- Scroll and Navigation Logic (triggered by scroll event) ---
        function handleScrollEnd() {
            const screenHeight = window.innerHeight;
            const newIndex = Math.round(swipeContainer.scrollTop / screenHeight);

            if (newIndex !== currentItemIndex && newIndex >= 0 && newIndex < contentItems.length) {
                const previousItemData = contentItems[currentItemIndex];
                if (previousItemData && previousItemData.type === 'video' && youtubePlayers[previousItemData.id]) {
                    const player = youtubePlayers[previousItemData.id];
                    if (player.getPlayerState && (player.getPlayerState() === YT.PlayerState.PLAYING || player.getPlayerState() === YT.PlayerState.BUFFERING)) {
                        player.pauseVideo();
                    }
                }
                currentItemIndex = newIndex;
                updatePreloadedContent(currentItemIndex);
                updateDisplayedItemInfo(currentItemIndex);
                const currentItemData = contentItems[currentItemIndex];
                if (currentItemData.type === 'video' && youtubePlayers[currentItemData.id]) {
                    const player = youtubePlayers[currentItemData.id];
                    if (player.getPlayerState && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                        setTimeout(() => {
                             if (player && typeof player.playVideo === 'function') player.playVideo();
                        }, 100);
                    }
                }
            } else if (newIndex === currentItemIndex) { // Scrolled but snapped back
                 const currentItemData = contentItems[currentItemIndex];
                 if (currentItemData.type === 'video' && youtubePlayers[currentItemData.id]) {
                     const player = youtubePlayers[currentItemData.id];
                     if (player.getPlayerState && player.getPlayerState() === YT.PlayerState.PAUSED) {
                         player.playVideo(); // Resume if paused by a quick swipe
                     }
                 }
            }
        }

        // --- Touch Handling for App Navigation (on appContainer) ---
        appContainer.addEventListener('touchstart', (e) => {
            let targetElement = e.target;
            let isTouchOnNavUI = false;
            // Check if touch started on the actions sidebar (the only active swipe zone for app nav now)
            while (targetElement && targetElement !== appContainer) {
                if (targetElement === uiActionsSidebar) { // Only uiActionsSidebar is checked now
                    isTouchOnNavUI = true;
                    break;
                }
                targetElement = targetElement.parentElement;
            }

            if (!isTouchOnNavUI || e.touches.length > 1) {
                isAppNavigating = false; 
                return; // Let event pass through for game/video interaction
            }

            isAppNavigating = true;
            const touch = e.touches[0];
            touchStartY = touch.clientY;
            touchStartScrollTop = swipeContainer.scrollTop;
        }, { passive: true });

        appContainer.addEventListener('touchmove', (e) => {
            if (!isAppNavigating || e.touches.length > 1) {
                return; 
            }
            e.preventDefault(); 
            const touch = e.touches[0];
            const deltaY = touch.clientY - touchStartY;
            swipeContainer.scrollTop = touchStartScrollTop - deltaY;
        }, { passive: false });

        appContainer.addEventListener('touchend', (e) => {
            if (!isAppNavigating) {
                return; 
            }
            isAppNavigating = false; 

            const touch = e.changedTouches[0];
            const deltaY = touch.clientY - touchStartY;
            
            if (Math.abs(deltaY) > MIN_SWIPE_DISTANCE_FOR_NAVIGATION) {
                if (deltaY < 0) { // Swiped Up
                    scrollToItem(currentItemIndex + 1);
                } else { // Swiped Down
                    scrollToItem(currentItemIndex - 1);
                }
            } else {
                scrollToItem(currentItemIndex); // Snap back
            }
        });

        let scrollEndTimeout;
        swipeContainer.addEventListener('scroll', () => {
            clearTimeout(scrollEndTimeout);
            scrollEndTimeout = setTimeout(handleScrollEnd, 150); 
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                console.log("DOM loaded, YouTube API not yet ready. Waiting for onYouTubeIframeAPIReady.");
            } else {
                console.log("DOM loaded and YouTube API ready, initializing content.");
                initializeVisibleContent();
            }

            // Fullscreen button listener
            if (fullscreenButton) {
                fullscreenButton.addEventListener('click', () => {
                    requestFullScreen();
                    fullscreenButton.style.display = 'none'; // Hide button after click
                });
            }

            // Event listeners for other UI buttons (like, dislike, etc.)
            uiOverlay.querySelectorAll('.actions-sidebar .action-button').forEach(button => {
                if (button.id !== 'fullscreenButton') { // Don't re-add listener to fullscreen button
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        console.log(`UI Button clicked: ${button.querySelector('span') ? button.querySelector('span').textContent : 'icon'}`);
                    });
                }
            });
        });
    </script>
</body>
</html>
